<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Alice Grace - I see through your eyes</title>
		<link>https://vzunnbii.github.io/posts/</link>
		<description>Recent content in Posts on Alice Grace - I see through your eyes</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 22 Apr 2019 15:15:45 +0700</lastBuildDate>
		<atom:link href="https://vzunnbii.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Report System thinking</title>
			<link>https://vzunnbii.github.io/posts/report_st/</link>
			<pubDate>Mon, 22 Apr 2019 15:15:45 +0700</pubDate>
			
			<guid>https://vzunnbii.github.io/posts/report_st/</guid>
			<description>Mục lục I. CAP
 Định lý CAP Khái niệm eventualy consistency  II. Throughtput - Latency
III. Phương pháp scale database (My SQL)
 Tại sao cần scale database? Một số phương pháp scale database (áp dụng MySQL)
 MySQL Replication MySQL Shard
Cách Pinterest scale database của họ
   IV. Task queue và Message queue
 Message queue Task queue  V. Credit

I. CAP Trong bối cảnh công nghệ hiện nay, hệ thống đang cần phải được mở rộng, thêm vào các nguồn lực cần thiết như máy tính, bộ nhớ,&amp;hellip; để hoàn thành tác vụ trong thời gian chấp nhận được.</description>
			<content type="html"><![CDATA[

<h1 id="mục-lục">Mục lục</h1>

<p>I. <a href="#CAP">CAP</a></p>

<ol>
<li><a href="#DL_CAP">Định lý CAP</a></li>
<li><a href="#eventualy">Khái niệm eventualy consistency</a></li>
</ol>

<p>II. <a href="#throughput">Throughtput - Latency</a></p>

<p>III. <a href="#scale_db">Phương pháp scale database (My SQL)</a></p>

<ol>
<li><a href="#why_1">Tại sao cần scale database?</a></li>

<li><p><a href="#pp">Một số phương pháp scale database (áp dụng MySQL)</a></p>

<ol>
<li><a href="#rep">MySQL Replication</a></li>

<li><p><a href="#shard">MySQL Shard</a></p>

<p><a href="#pin">Cách Pinterest scale database của họ</a></p></li>
</ol></li>
</ol>

<p>IV. <a href="#task_message">Task queue và Message queue</a></p>

<ol>
<li><a href="#mess">Message queue</a></li>
<li><a href="#task">Task queue</a></li>
</ol>

<p>V. <a href="#credit">Credit</a></p>

<p><a name = "CAP"></a></p>

<h1 id="i-cap">I. CAP</h1>

<p>Trong bối cảnh công nghệ hiện nay, hệ thống đang cần phải được mở rộng, thêm vào các nguồn lực cần thiết như máy tính, bộ nhớ,&hellip; để hoàn thành tác vụ trong thời gian chấp nhận được. Để xử lý được luồng công việc ngày một lớn, cần phải sử dụng thêm các sản phẩn phần cứng, khi đó sẽ có nhiều bất cập liên quan đến việc đồng bộ và họat động song song giữa các thành phần của hệ thống. Và đây chính là lúc định lý CAP nhập cuộc.</p>

<p>Định lý CAP nêu rõ rằng, trong một hệ thống được phân bổ (một tập hợp các nodes có liên kết chia sẻ dữ liệu với nhau), bạn chỉ có thể đảm bảo hai trong ba ràng buộc trên một cặp đọc/ghi sau đây: Tính nhất quán, Tính sẵn sàng và Dung sai phân mảnh. Tuy nhiên không có hệ thống nào có thể đạt được cả 3 yếu tố trên và bắt buộc phải lựa chọn dựa trên các thuộc tính của hệ thống.</p>

<p><a name = "DL_CAP"></a></p>

<h2 id="1-định-lý-cap">1. Định lý CAP</h2>

<p>C - Consistency - tính nhất quán: mọi yêu cầu đọc sẽ được trả về kết quả ghi gần nhất hoặc thông báo lỗi.</p>

<p>A - Availability - tính sẵn sàng: mọi yêu cầu đều nhận được kết quả, không đảm bảo sẽ nhận được kết quả mới nhất của thông tin.</p>

<p>P - Partition tolenrance - dung sai phân mảnh: hệ thống vẫn tiếp tục hoạt động kể cả khi có lỗi kết nối mạng giữa một số nodes.</p>

<pre><code>Một hệ thống mạng thì rất dễ gặp lỗi, vì vậy bạn cần đảm bảo hệ thống vẫn hoạt động dù có một số vùng có kết nối yếu. Do đó bạn cần lựa chọn giữa tính nhất quán và tính sẵn sàng dựa trên tính chất của phần mềm.
</code></pre>

<p><a name = "Eventualy"></a></p>

<h2 id="2-khái-niệm-eventualy-consistency">2. Khái niệm eventualy consistency</h2>

<p>Với vô số bản copy của cũng một dữ liệu, vấn đề phải đối mặt là làm sao đồng bộ chúng để mọi người dùng có sự nhất quán về góc nhìn với dữ liệu.</p>

<ul>
<li>Weak consistency</li>
</ul>

<p>Đồng bộ yếu: Sau khi có cập nhật về thông tin, người dùng chỉ đọc có thể sẽ thấy hoặc không thấy phiên bản cập nhật của dữ liệu. Dữ liệu trên hệ thống sẽ được lưu dưới vùng nhớ tạm. Tính đồng bộ yếu thường được sử dụng trong các tác vụ sử dụng thời gian thực như VoIP, gọi video, game online nhiều người chơi. Khi có lỗi mất kết nối/kết nối yếu xảy ra, người dùng sẽ bị mất những thông tin được truyền đi trong thời gian xảy ra lỗi.</p>

<ul>
<li>Eventual consistency</li>
</ul>

<p>Đồng bộ cuối cùng: Là một dạng của đồng bộ yếu, chỉ khác là cuối cùng thông tin vẫn được cập nhật. Trong thời gian đồng bộ, người dùng chỉ đọc vẫn sẽ thấy được những dữ liệu cũ. Sau khi hoàn tất quá trình đồng bộ, mọi yêu cầu đọc đều sẽ nhận được kết quả là phiên bản mới nhất của thông tin.</p>

<p><a name = "throughput"></a></p>

<h1 id="ii-throughput-latency">II. Throughput - Latency</h1>

<ul>
<li><p>Latency: Thời gian cần thiết để hoàn thành 1 tác vụ hoặc để tạo ra một kết quả.</p></li>

<li><p>Throughput: Số tác vụ hoặc kết quả trong một đơn vị thời gian.</p></li>
</ul>

<p>Ví dụ: Một dây chuyền sản xuất cần 8 giờ để hoàn thành 1 chiếc xe hơi. Trong một ngày nhà máy đó sản xuất được 120 chiếc xe.</p>

<ul>
<li>Latency: 8 giờ</li>
<li>Throughput: 120 xe/ngày hay 5 xe/giờ</li>
</ul>

<p><a name = "scale_db"></a></p>

<h1 id="iii-phương-pháp-scale-database-my-sql">III. Phương pháp scale database (My SQL)</h1>

<p><a name = "why_1"></a></p>

<h2 id="1-tại-sao-cần-scale-database">1. Tại sao cần scale Database?</h2>

<p>Với ứng dụng web có traffic lớn thì việc scale là không thể tránh khỏi. Scale thì có thể tiến hành trên nhiều tầng, như tầng app, tầng db. Database là một hệ thống quan trọng và là một dịch vụ xương sống giúp toàn bộ hệ thống hoạt động, do đó, nó cũng trở thành điểm yếu trong quá trình mở rộng hệ thống. Khi mở rộng hệ thống, lượng truy cập vào các web server sẽ tăng lên, kéo theo các kết nối từ web server đến database sẽ tăng lên và khiến database quá tải và nó trở thành điểm yếu của toàn hệ thống.</p>

<p><a name = "pp"></a></p>

<h2 id="2-một-số-phương-pháp-scale-database-áp-dụng-mysql">2. Một số phương pháp scale database (áp dụng MySQL)</h2>

<p><a name = "rep"></a></p>

<h3 id="2-1-mysql-replication">2.1. MySQL Replication</h3>

<h4 id="2-1-1-giới-thiệu">2.1.1. Giới thiệu</h4>

<p>Right tool for right job. Trước tiên phải hiểu là MySQL Replication không phải là giải pháp giải quyết mọi bài toán về quá tải hệ thống cơ sở dữ liệu. Để mở rộng một hệ thống ta có hai phương pháp mở rộng là scale up và scale out. Bắt đầu với 1 máy chủ thì hai phương pháp trên được diễn giải như sau:</p>

<ul>
<li><p>Scale up có nghĩa là với một máy chủ ta làm cách nào đó để nó có thể phục vụ nhiều hơn số lượng kết nối, truy vấn. Nghĩa là giá trị 1/(số kết nối phục vụ) càng nhỏ thì càng tốt. Để đạt được mục đích này thì có 2 phương pháp:</p>

<ul>
<li>Tăng phần cứng lên cho máy chủ. Nghĩa là với CPU là 4 core, RAM là 8 GB phục vụ được 500 truy vấn thì giờ ta tăng CPU lên 24 core, RAM tăng lên 32GB -&gt; máy chủ có thể phục vụ được số lượng kết nối truy vấn nhiều hơn.</li>
<li>Optimize ứng dụng, câu truy vấn. Ví dụ với câu truy vấn lấy dữ liệu tốn 5s để lấy được dữ liệu, sau đó mới trả lại tài nguyên cho hệ thống phục vụ các truy vấn khác. Máy chủ có thể đồng thời phục vụ 500 truy vấn dạng như vậy thì nếu ta tối ưu để truy vấn lấy dữ liệu chỉ tốn 1s =&gt; Máy chủ có thể phục vụ đồng thời nhiều truy vấn hơn.</li>
</ul></li>

<li><p>Scale out là giải pháp tăng số lượng server và dùng các giải pháp load-balacer để phân phối truy vấn ra nhiều server. Ví dụ bạn có 1 server có khả năng phục vụ 500 truy vấn. Nếu ta dựng thêm 5 server nữa có cấu hình tương tự, đặt thêm một LB phía trước để phân phối thì có khả năng hệ thống có thể phục vụ đc 5x500 truy vấn đồng thời.</p></li>
</ul>

<p>MySQL Replication là một giải pháp scale out (tăng số lượng instance MySQL) nhưng không phải bài toán nào cũng dùng được. Các bài toán mà MySQL Replication sẽ giải quyết tốt:</p>

<ul>
<li><p><strong>Scale Read</strong></p>

<ul>
<li>Scale Read thường gặp ở các ứng dụng mà số truy vấn đọc dữ liệu nhiều hơn ghi, tỉ lệ read/write có thể <sup>80</sup>&frasl;<sub>20</sub> hoặc hơn. Các ứng dụng thường gặp là báo, trang tin tức.</li>
<li>Với scale read ta sẽ chỉ có một Master instance phục vụ cho việc đọc/ghi dữ liệu. Có thể có một hoặc nhiều Slave instance chỉ phục vụ cho việc đọc dữ liệu.</li>
<li>Một số ứng dụng write nhiều (thương mại điện tử) cũng có sử dụng MySQL Replication để scale out hệ thống.</li>
</ul></li>

<li><p><strong>Data Report</strong></p>

<ul>
<li>Một số hệ thống cho phép một số người (leader, manager, người làm report, thống kê, data) truy cập vào dữ liệu trên production phục vụ cho công việc của họ. Việc truy cập trực tiếp vào data production sẽ rất nguy hiểm vì:</li>
<li>Vô tình chỉnh sửa làm sai lệnh dữ liệu (nếu có quyền insert, update)</li>
<li>Vô tình thực thi các câu truy vấn tốn nhiều tài nguyên, thời gian truy vấn dài làm treo hệ thống.</li>
<li>Việc setup một máy chủ làm data report (application cũng sẽ không kết nối tới server này) làm giảm thiểu 2 rủi ro trên.</li>
</ul></li>

<li><p><strong>Real time backup</strong></p>

<ul>
<li>Với cơ sở dữ liệu lớn việc backup không thể thực hiện thường xuyên được (hàng giờ, hàng phút). Với các ứng dụng giao dịch tài chính, thanh toán, TMDT nếu bị mất dữ liệu 1 giờ, 1 ngày thì thiệt hại sẽ rất lớn (máy chủ chính tự dưng bị hỏng). Real time backup là một giải pháp bổ sung cho offline backup, chạy đồng thời cả 2 phương pháp này để bảo đảm sự an toàn cho dữ liệu.</li>
</ul></li>
</ul>

<h4 id="2-1-2-cách-thức-hoạt-động">2.1.2. Cách thức hoạt động</h4>

<h5 id="2-1-2-1-một-số-mô-hình-hoạt-động">2.1.2.1. Một số mô hình hoạt động</h5>

<p align="center">
  <img src="http://i.imgur.com/mevNr10.png">
  <br/>
</p>

<p>Với cả hai mô hình ta luôn chỉ có 1 Master database phục vụ cho Write dữ liệu, có thể có một hoặc nhiều Slave database. Tùy từng mô hình ta có thể cấu hình mỗi web node connect vào một Slave DB tương ứng hoặc có thể dùng một LB đặt trước cụm Slave để LB tự động phân phối connection vào từng Slave DB theo thuật toán của LB.</p>

<p align="center">
  <img src="http://i.imgur.com/etkJXxd.png">
  <br/>
</p>

<h5 id="2-1-2-2-cách-thức-hoạt-động">2.1.2.2. Cách thức hoạt động</h5>

<p>Trên Master:</p>

<ul>
<li>Các kết nối từ web app tới Master DB sẽ mở một Session_Thread khi có nhu cầu ghi dữ liệu. Session_Thread sẽ ghi các statement SQL vào một file binlog (ví dụ với format của binlog là statement-based hoặc mix). Binlog được lưu trữ trong data_dir (cấu hình my.cnf) và có thể được cấu hình các thông số như kích thước tối đa bao nhiêu, lưu lại trên server bao nhiêu ngày.</li>
<li>Master DB sẽ mở một Dump_Thread và gửi binlog tới cho I/O_Thread mỗi khi I/O_Thread từ Slave DB yêu cầu dữ liệu.</li>
</ul>

<p>Trên Slave:</p>

<ul>
<li>Trên mỗi Slave DB sẽ mở một I/O_Thread kết nối tới Master DB thông qua network, giao thức TCP (với MySQL 5.5 replication chỉ hỗ trợ Single_Thread nên mỗi Slave DB sẽ chỉ mở duy nhất một kết nối tới Master DB, các phiên bản sau 5.6, 5.7 hỗ trợ mở đồng thời nhiều kết nối hơn) để yêu cầu binlog.</li>
<li>Sau khi Dump_Thread gửi binlog tới I/O_Thead, I/O_Thread sẽ có nhiệm vụ đọc binlog này và ghi vào relaylog.</li>
<li>Đồng thời trên Slave sẽ mở một SQL_Thread, SQL_Thread có nhiệm vụ đọc các event từ relaylog và apply các event đó vào Slave =&gt; quá trình replication hoàn thành.</li>
</ul>

<p><a name = "shard"></a></p>

<h3 id="2-2-shard-mysql">2.2. Shard MySQL</h3>

<p><center> <img src="https://s3-us-west-1.amazonaws.com/morpheus-staging/system/spud_media/188/original/tables1.jpg?1414453819"> </center></p>

<p>Sharding là một tiến trình lưu giữ các bản ghi dữ liệu qua nhiều thiết bị để đáp ứng yêu cầu về sự gia tăng dữ liệu. Khi kích cỡ của dữ liệu tăng lên, một thiết bị đơn ( 1 database hay 1 bảng) không thể đủ để lưu giữ dữ liệu. Sharding giải quyết vấn đề này với việc mở rộng phạm vi theo bề ngang (horizontal scaling). Với Sharding, bạn bổ sung thêm nhiều thiết bị để hỗ trợ cho việc gia tăng dữ liệu và các yêu cầu của các hoạt động đọc và ghi.</p>

<p>Đối với những hệ thống có dữ liệu rất lớn thì đến một lúc nào đó, số dũ liệu trong bảng lên đến hàng triệu, việc query trở nên vô cùng ì ạch và tốn rất nhiều dung lượng bộ nhớ. Kỹ thuật sharding giúp ta giải quyết vấn đề này một cách nhanh chóng bằng cách chia nhỏ bảng hay db ra làm các phần khác nhau, chúng có cấu trúc dữ liệu giống nhau nhưng lưu các dữ liệu khác nhau để giảm tải thay cho việc chỉ dùng 1 bảng.</p>

<p>Ví dụ:</p>

<h4 id="cách-pinterest-scale-mysql-của-họ"><strong>Cách Pinterest scale MySQL của họ</strong></h4>

<p>Bài viết được lược dịch từ <a href="https://medium.com/@Pinterest_Engineering/sharding-pinterest-how-we-scaled-our-mysql-fleet-3f341e96ca6f">Sharding Pinterest: How we scaled our MySQL fleet</a> (viết từ 17/8/2015) và tham khảo từ bài <a href="https://kipalog.com/posts/Pinterest-da-thuc-hien-scaled-MySQL-cua-ho-nhu-the-nao">Pinterest đã thực hiện scaled MySQL của họ như thế nào</a> (viết từ 22/3/2017).</p>

<h5 id="a-intro">a. Intro</h5>

<blockquote>
<p>“Shard. Or do not shard. There is no try.”  —  Yoda</p>
</blockquote>

<p>&ldquo;Pinterest là công cụ khám phá dành cho tất cả những gì chúng ta hứng thú&rdquo;. Do đó, dữ liệu của Pinterest là vô hạn với cả triệu chủ đề, từ những bức hình giúp thư giãn đầu óc, hình đồ ăn, hình socola phủ dâu tây, hình Star Trek quotes,&hellip; &ldquo;Nhìn từ góc độ dữ liệu, Pinterest là biểu đồ lớn nhất mô tả sự quan tâm của con người trên thế giới&rdquo;. Không chỉ xem hình hoặc video, user của Pin (gọi tắt là Piner) có thể thực hiện các hoạt động như follow, pin (save), share,&hellip; Đã có khoảng 50 tỷ Pins được lưu bởi Piner trong khoảng 1 tỷ boads (1 Piner có nhiều board, mỗi board có nhiều pins).</p>

<h5 id="b-why-tại-sao-cần-scale-database">b. Why: Tại sao cần scale database?</h5>

<p>Câu chuyện bắt đầu khi hệ thống gặp vấn đề. Vào năm 2011, Pinterest phát triển nhanh và mạnh mẽ với số lượng Piner tăng đột biến. Lượng truy cập ngày càng tăng, hệ thống giảm dần khả năng tải trọng với lượng dữ liệu ngày một nhiều. Khoảng tháng <sup>9</sup>&frasl;<sub>2011</sub>, hệ thống gần như sập hoàn toàn cho dù đã sử dụng kỹ thuật NoSQL cũng như MySQL slave. Chỉ còn cách tái thiết kế cấu trúc cho toàn bộ hệ thống. Và lúc này, đội ngũ dev của Pinterest phải thay đổi góc nhìn về yêu cầu của hệ thống, từ đó thay đổi toàn bộ cấu trúc và xây dựng nền tảng mới.</p>

<h5 id="c-yêu-cầu-của-hệ-thống">c. Yêu cầu của hệ thống</h5>

<p>Các yêu cầu đặt ra cho hệ thống lúc này là:</p>

<ul>
<li>Ổn định, hoạt động nhanh, dễ scale.</li>
<li>Mọi thông tin mà Piner tạo ra phải được đảm bảo tính khả dụng.</li>
<li>Khi query N pins trên board thì đảm bảo thứ tự trước sau.</li>
<li>Update đơn giản nhất có thể.</li>
</ul>

<h5 id="d-triết-lý-thiết-kế">d. Triết lý thiết kế</h5>

<p>Một khi đã mở rộng cơ sở dữ liệu, chúng ta không thể sử dụng phép join, cài đặt khóa ngoại hay index cho toàn bộ CSDL nữa mà chỉ có thể dùng cho các CSDL con.</p>

<p>Đồng thời, load balancing cũng cần được đảm bảo. Việc di chuyển data lung tung, nhất là chuyển từng mục một rất dễ gây ra lỗi và khiến hệ thống phức tạp không cần thiết. Nếu nhất định phải di chuyển dữ liệu thì tốt nhất nên chuyển toàn bộ note ảo sang note vật lý.</p>

<h5 id="e-thực-hành">e. Thực hành</h5>

<p>Hệ thống sau khi xây dụng cần phải thỏa mãn các tiêu chí đã đề ra, đảm bảo perfoming tốt và dễ dàng sửa chữa. Nói cách khác là nó đừng có dở tệ, vậy nên team Pinterest đã chọn một công nghệ &ldquo;chín&rdquo; như chính nền tảng CSDL mà họ sử dụng vậy, MySQL. Câu hỏi đặt ra ở đây là, tại sao lại sử dụng một HQT CSDL xưa cũ như MySQL trong khi cách HQT mới đang lên như diều gặp gió (MongoDB, Cassandra, Membase,&hellip;). Câu trả lời chính là do những HQT mới được cập nhật nhiều tính năng (như auto-scaling) khó có khả năng phát triển về lâu về dài và dễ crash với yêu cầu cao.</p>

<p>Bên cạnh đó, tác giả có nói:</p>

<pre><code>Tui vẫn thường khuyên mọi người nên khởi đầu mà tránh dùng các công cụ quá mới mẻ và tích hợp nhiều tính năng. Hãy cố gắng chỉ dùng MySQL thôi, tin tui đi, tui có kinh nghiệm đau thương về vụ này đó.
</code></pre>

<ul>
<li>Cấu hình được sử dụng là master-master, bắt đàu với 8 servers EC2, mỗi server EC2 chạy trên 1 instance MySQl và có 1 EC2 đi kèm, nhằm tránh trường hợp lỗi hệ thống khi có 1 server bị sập. Ví dụ, server 1A và 1B là 1 cặp master-master, lúc đầu 1A là master chính, 1B support cho 1A. Khi 1A die, 1B đảo chính, lên làm master. Khi 1A quay lại, nó mất ngôi và trở thành support cho 1B.</li>
</ul>

<p><center> <img src="https://cdn-images-1.medium.com/max/1600/0*pImQYoxO9l9J3LG8.png"> </center></p>

<ul>
<li>Mọi thao tác read/write chỉ tác động lên master. Mỗi server EC2 có thể chứa nhiều dữ liệu:</li>
</ul>

<p><center> <img src="https://cdn-images-1.medium.com/max/1600/0*dB5aSiZrInFvbefe.png"> </center></p>

<p>Hãy chú ý rằng mỗi database được đặt tên độc nhất vì chúng là một phần của dữ liệu chính. Họ đã quyết định rằng, một khi chia dữ liệu vào một shard, nó sẽ ở đó vĩnh viễn, không bao giờ bị chuyển đi nơi khác.</p>

<ul>
<li>Họ có một bảng lưu thông tin về nơi lưu trữ các shard trên ZooKeepala</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="o">[{</span><span class="err">“</span><span class="kt">range</span><span class="err">”</span><span class="kt">:</span>     <span class="o">(</span><span class="err">0</span>,<span class="err">511</span><span class="o">)</span>, <span class="err">“</span><span class="kt">master</span><span class="err">”</span><span class="kt">:</span> <span class="err">“</span><span class="kt">MySQL001A</span><span class="err">”</span>, <span class="err">“</span><span class="kt">slave</span><span class="err">”</span><span class="kt">:</span> <span class="err">“</span><span class="kt">MySQL001B</span><span class="err">”</span><span class="o">}</span>,
 <span class="o">{</span><span class="err">“</span><span class="kt">range</span><span class="err">”</span><span class="kt">:</span> <span class="o">(</span><span class="err">512</span>, <span class="err">1023</span><span class="o">)</span>, <span class="err">“</span><span class="kt">master</span><span class="err">”</span><span class="kt">:</span> <span class="err">“</span><span class="kt">MySQL002A</span><span class="err">”</span>, <span class="err">“</span><span class="kt">slave</span><span class="err">”</span><span class="kt">:</span> <span class="err">“</span><span class="kt">MySQL002B</span><span class="err">”</span><span class="o">}</span>,
    <span class="kt">...</span>
 <span class="o">{</span><span class="err">“</span><span class="kt">range</span><span class="err">”</span><span class="kt">:</span> <span class="o">(</span><span class="err">3584</span>, <span class="err">4095</span><span class="o">)</span>, <span class="err">“</span><span class="kt">master</span><span class="err">”</span><span class="kt">:</span> <span class="err">“</span><span class="kt">MySQL008A</span><span class="err">”</span>, <span class="err">“</span><span class="kt">slave</span><span class="err">”</span><span class="kt">:</span> <span class="err">“</span><span class="kt">MySQL008B</span><span class="err">”</span><span class="o">}]</span></code></pre></div>
<p>// <em><code>(0,511)</code> tương ứng <code>db00000 to db00511</code></em></p>

<ul>
<li>Tạo universally unique IDs (UUID) cho mọi project để có thể phân phối data được viết vào các shard một cách chính xác và balance nhất.

<ul>
<li>Họ tạo UUID là 1 số 64 bit, dùng cho mọi query từ bên ngoài vào, có cấu trúc:
<br /></li>
</ul></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala">  <span class="nc">UUID</span> <span class="k">=</span> <span class="o">(</span><span class="n">shard</span> <span class="nc">ID</span> <span class="o">&lt;&lt;</span> <span class="mi">46</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="k">type</span> <span class="kt">ID</span> <span class="kt">&lt;&lt;</span> <span class="err">36</span><span class="o">)</span> <span class="o">|</span> <span class="o">(</span><span class="n">local</span> <span class="nc">ID</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="o">)</span></code></pre></div>
<p>Với:
* <code>shard ID:</code> là 1 số 16bit, có vai trò là ID của shard.
* <code>type ID:</code> là 1 số 10bit, có vai trò chỉ ra type củaobject. Ví dụ nếu type ID = 1 có nghĩa object type là Pin, type ID = 2 ứng với object type là Board chẳng hạn.
* <code>local ID:</code> là 1 số 36 bit, có vai trò là ID của records bên trong shard, có giá trị auto increment.</p>

<p>Từ công thức bên trên, có thể thấy UUID được tạo bằng cách:</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php">(Dịch trái shard ID 46 bit) bitwise OR (Dịch trái type ID 36 bit) bitwise OR (Dịch trái local ID 0 bit)</code></pre></div>
<p>Ví dụ với URL: <a href="https://www.pinterest.com/pin/241294492511762325/">https://www.pinterest.com/pin/241294492511762325/</a>, thì UUID nhận được là 241294492511762325. Tiến hành decompose UUID theo cách sau:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Shard</span> <span class="nc">ID</span> <span class="k">=</span> <span class="o">(</span><span class="mi">241294492511762325</span> <span class="o">&gt;&gt;</span> <span class="mi">46</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span> <span class="k">=</span> <span class="mi">3429</span>
<span class="nc">Type</span> <span class="nc">ID</span>  <span class="k">=</span> <span class="o">(</span><span class="mi">241294492511762325</span> <span class="o">&gt;&gt;</span> <span class="mi">36</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0x3FF</span> <span class="k">=</span> <span class="mi">1</span>  <span class="c1">//type Pin -&gt; query vào table pins
</span><span class="c1"></span><span class="nc">Local</span> <span class="nc">ID</span> <span class="k">=</span> <span class="o">(</span><span class="mi">241294492511762325</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFF</span> <span class="k">=</span> <span class="mi">7075733</span></code></pre></div>
<p>Từ công thức trên, có thể thấy được:</p>

<ul>
<li><code>Shard ID</code> được decompose từ việc dịch phải 46bit UUID, sau đó bitwise AND với 0xFFFF (hay là 0b1111111111111111). Nghĩa là cắt đúng vị trí của Shard ID được dịch trái ở công thức tạo UUID bên trên. Trong trường hợp này thì việc bitwise AND với 0xFFFF là hơi thừa. Tuy nhiên nó lại có ích nếu như Shard ID ko còn đứng ở phía bên phải nhất của 64bit UUID nữa.</li>
<li><code>Type ID</code> và <code>Local ID</code> được decompose tương tự, và cần phải bitwise AND tương ứng với 1 số 10bit và 1 số 36bit toàn 1. Như vậy là mọi thông tin cần thiết đã được decompose một cách toàn vẹn, mà lại còn nhanh nữa chứ. Tính toán trên bit mà.</li>
</ul>

<p>Sau khi đã có đầy đủ thông tin, chỉ việc query:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">conn</span> <span class="o">=</span> <span class="n">MySQLdb</span><span class="p">.</span><span class="k">connect</span><span class="p">(</span><span class="k">host</span> <span class="o">=</span> <span class="err">”</span><span class="n">MySQL007A</span><span class="err">”</span><span class="p">)</span>
<span class="n">conn</span><span class="p">.</span><span class="k">execute</span><span class="p">(</span><span class="err">“</span><span class="k">SELECT</span> <span class="k">data</span> <span class="k">FROM</span> <span class="n">db03429</span><span class="p">.</span><span class="n">pins</span> <span class="k">where</span> <span class="n">local_id</span> <span class="o">=</span> <span class="mi">7075733</span><span class="err">”</span><span class="p">)</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">//</span> <span class="nx">Host</span> <span class="nx">MySQL007A</span> <span class="nx">được</span> <span class="nx">nhặt</span> <span class="nx">ra</span> <span class="nx">từ</span> <span class="nx">shard</span> <span class="nx">ID</span> <span class="mi">3429</span><span class="p">,</span> <span class="nx">có</span> <span class="k">range</span> <span class="nx">nằm</span> <span class="nx">trong</span> <span class="p">{</span><span class="err">“</span><span class="k">range</span><span class="err">”</span><span class="p">:</span> <span class="p">(</span><span class="mi">3072</span><span class="p">,</span> <span class="mi">3583</span><span class="p">),</span> <span class="err">“</span><span class="nx">master</span><span class="err">”</span><span class="p">:</span> <span class="err">“</span><span class="nx">MySQL007A</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="nx">slave</span><span class="err">”</span><span class="p">:</span> <span class="err">“</span><span class="nx">MySQL007B</span><span class="err">”</span><span class="p">},,</span> <span class="nx">nên</span> <span class="nx">nó</span> <span class="nx">chọn</span> <span class="nx">host</span> <span class="nx">MySQL007A</span> <span class="nx">để</span> <span class="nx">query</span> <span class="nx">thôi</span><span class="p">.</span></code></pre></div>
<h5 id="f-cấu-trúc-bảng">f. Cấu trúc bảng</h5>

<p>Với lượng dữ liệu lớn và khó phân loại, Pinterest liệu có phải xây dựng 1 CSDL lớn và đồ sộ với khoảng 15-20 thuộc tính không?</p>

<p>Câu trả lời là không. Ngược lại là khác. Cấu trúc bảng của Pinterest chỉ gồm:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">pins</span> <span class="p">(</span>
  <span class="n">local_id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="k">data</span> <span class="nb">TEXT</span><span class="p">,</span>
  <span class="n">ts</span> <span class="k">TIMESTAMP</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span>
<span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">;</span></code></pre></div>
<p>Ví dụ, một đối tượng Pin sẽ trông như thế này:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="p">{</span><span class="err">“</span><span class="n">details</span><span class="err">”</span><span class="p">:</span> <span class="err">“</span><span class="n">New</span> <span class="n">Star</span> <span class="n">Wars</span> <span class="n">character</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">link</span><span class="err">”</span><span class="p">:</span> <span class="err">“</span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">webpage</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">asdf</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">user_id</span><span class="err">”</span><span class="p">:</span> <span class="mi">241294629943640797</span><span class="p">,</span> <span class="err">“</span><span class="n">board_id</span><span class="err">”</span><span class="p">:</span> <span class="mi">241294561224164665</span><span class="p">,</span> <span class="err">…</span><span class="p">}</span></code></pre></div>
<p>Tại sao? Vì giả sử nếu phải thêm 1 column mới cho 1 table theo cách tiếp cận cũ, thì việc alter table sẽ rất nặng (do phải alter cho tất cả các table tương ứng của các shard). Tuy nhiên với cách làm này, thì khỏi cần alter gì cả, chỉ cần khai báo ở tầng app giá trị default cho column mới mỗi khi muốn đọc ra thôi. Pinterest hơn 3 năm rồi (tính tới thời điểm bài gốc được đăng) chưa từng phải alter table.</p>

<ul>
<li>Khi insert 1 record mới, họ chỉ định ghi nó vào shard ID nào, type ID là gì. Sau khi record được insert rồi, nó sẽ trả về local ID, lúc này sẽ kết hợp với Shard ID và Type ID để cho ra UUID theo cách bên trên. Quá lợi hại.</li>
</ul>

<p><a name = "task_message"></a></p>

<h1 id="iv-task-queue-và-message-queue">IV. Task queue và Message queue</h1>

<p><a name = "mess"></a></p>

<h2 id="1-message-queue">1. Message queue</h2>

<p>Hàng đợi thông điệp nhận, giữ và gửi tin nhắn. Nếu một tác vụ cần thời gian lớn để thực hiện nội tuyến, bạn có thể dùng hàng đợi thông điệp với luông công việc như sau:</p>

<ul>
<li>Phần mềm đăng một công việc lên hàng đợi, gửi thông báo tới những nhân viên có liên quan đến công việc đó.</li>
<li>Nhân viên lấy công việc từ hàng đợi, thực hiện nó, sau đó đánh dấu công việc thành đã hoàn thành.</li>
</ul>

<p>Khi đó, người dùng sẽ không bị block và công việc thì vẫn chạy ngầm ở dưới nền. Trong quá trình đó, hệ thống cho phép client thực hiện một vài hành động nhỏ để làm như tác vụ đó đã hoàn thành. Ví dụ khi bạn đăng 1 tweet trên twitter, tweet đó có thể xuất hiện ngay trên timeline của bạn, nhưng cần một thời gian nhỏ để bài đăng đó đến được với những người follow bạn.</p>

<ul>
<li><a href="https://redis.io/">Redis</a> là một mã nguồn mở (được cấp phép BDS), lưu trữ cấu trúc dữ liệu trong bộ nhớ, được sử dụng làm cơ sở dữ liệu, bộ đệm và môi giới tin nhắn. Nó hỗ trợ các cấu trúc dữ liệu như chuỗi, băm, danh sách, bộ, bộ được sắp xếp với các truy vấn phạm vi, bitmap, hyperloglog, chỉ mục không gian địa lý với các truy vấn và luồng bán kính. Redis có thể hữu dụng như một nhà trung gian tin nhắn cỡ nhỏ nhưng thông điệp có thể bị mất.</li>
<li><a href="https://www.rabbitmq.com/">RabbitMQ</a> là một phần mềm trung gian tin nhắn mã nguồn mở được phát triển rộng rãi. RabbitMQ rất nhẹ và dễ triển khai trên cơ sở và trên đám mây. Nó hỗ trợ nhiều giao thức nhắn tin. RabbitMQ có thể được triển khai trong các cấu hình phân tán và liên kết để đáp ứng các yêu cầu có tính sẵn sàng cao, quy mô cao. RabbitMQ phổ biến nhưng yêu cầu thiết bị của bạn phải tương thích với &ldquo;AMQP&rdquo; protocol và tự quản lý nodes của mình.</li>
<li><a href="https://aws.amazon.com/sqs/">Amazon SQS</a> là hệ thống quản lý hàng đợi thông điệp hoàn thiện cho phép bạn tách rời và chia tỷ lệ microservice, hệ thống phân tán và ứng dụng không có máy chủ. ASQS được khuyến khích sử dụng nhưng có thể có thời gian phản hồi cao và nhiều nguy cơ thông điệp bị gửi nhiều hơn 1 lần.</li>
</ul>

<p><a name = "task"></a></p>

<h2 id="2-task-queue">2. Task queue</h2>

<p>Hàng đợi nhiệm vụ nhận nhiệm vụ và các dữ liệu liên quan, chạy chúng lên sau đó gửi lại kết quả. Nó hỗ trợ việc lên lịch và chạy các tính toán chuyên sâu trong nền.</p>

<p><strong>Celery</strong> có hỗ trợ lên lịch và chủ yếu hỗ trợ python.</p>

<p><a name = "credit"></a></p>

<h1 id="v-credit">V. Credit</h1>

<ul>
<li><a href="https://github.com/donnemartin/system-design-primer#message-queues">System disign Primer</a></li>
<li><a href="https://kipalog.com/posts/Pinterest-da-thuc-hien-scaled-MySQL-cua-ho-nhu-the-nao">Pinterest đã thực hiện scaled MySQL của họ như thế nào</a></li>
<li><a href="https://medium.com/@Pinterest_Engineering/sharding-pinterest-how-we-scaled-our-mysql-fleet-3f341e96ca6f">Sharding Pinterest: How we scaled our MySQL fleet</a></li>
<li><a href="http://bloghoctap.com/technology/web-scalability-101-database-va-microservices.html">Database và Microservices</a></li>
<li><a href="https://kipalog.com/posts/1-so-van-de-ve-MySQL-Performance">1 số vấn đề về MySQL Performance</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Tâm sự mỏng</title>
			<link>https://vzunnbii.github.io/posts/tamsu/</link>
			<pubDate>Tue, 16 Apr 2019 13:03:53 +0700</pubDate>
			
			<guid>https://vzunnbii.github.io/posts/tamsu/</guid>
			<description>Bạn có biết, một trong những yếu tố khiến người ta mắc hội chứng sợ đám đông là sự tự ti.
Tự ti có thể do nhiều lý do, chủ yếu do sự không hài lòng về bản thân. Có thể do ngoại hình, tài năng, sự khác biệt,&amp;hellip; Ai cũng từng ít nhất một lần trong đời cảm thấy không tự tin trước đám đông, có thể là khi đi tới một bữa tiệc hay phải lên nói trước đông người.</description>
			<content type="html"><![CDATA[

<p>Bạn có biết, một trong những yếu tố khiến người ta mắc hội chứng sợ đám đông là sự tự ti.</p>

<p>Tự ti có thể do nhiều lý do, chủ yếu do sự không hài lòng về bản thân. Có thể do ngoại hình, tài năng, sự khác biệt,&hellip; Ai cũng từng ít nhất một lần trong đời cảm thấy không tự tin trước đám đông, có thể là khi đi tới một bữa tiệc hay phải lên nói trước đông người.</p>

<p>Tự ti cũng có nhiều kiểu. Tui thấy tui xấu quá trong khi ai cũng lộng lẫy, tui tự nép mình vào góc. Tui thấy đồ của tui cùi quá, trong khi ai cũng toàn là đồ xịn, tui tự giấu đồ của mình đi. Tui thấy tui học dở quá, mọi người đều có kết quả tốt, tui không muốn nói chuyện với ai về chuyện học tập cả. Có nhiều lý do khiến chúng ta tự ti, và điểm chung giữa chúng là do chúng ta để tâm quá nhiều tới người khác.</p>

<h3 id="1-để-tâm-đến-người-khác">1. Để tâm đến người khác</h3>

<p>Vì sao chúng ta thường run khi thuyết trình trước đám đông? Vì khi ấy mọi ánh mắt đều đổ dồn vào mình, mỗi hành động đều có thể trở thành trò cười cho cả hội trường. Khi ấy bất giác mình không dám làm gì cả, lời nói cũng ngày một ngập ngừng, ậm ờ liên tục dù đã thuộc bài, hoặc là lên chỉ dám nhìn xuống mũi giày mà nói. Thật ra đó là do chúng ta quá để ý đến người khác, để ý đám đông đang nhìn vào đâu, để ý họ có để ý đến mình không&hellip; Đó chính là lý do chính. Tương tự vậy, chúng ta thường run khi thấy crush vì chúng ta quá để tâm đến hành động của họ, lúc nào cũng muốn biết họ đang làm gì,đang nhìn ai, có đang nghe mình nói không,&hellip; Vì vậy, nguyên nhân của tự ti chủ yếu là do chính chúng ta đang quá để tâm đến suy nghĩ của người khác, từ đó áp đặt suy nghĩ lên chính mình, sau đó lại so sánh mình với họ, rồi tự mình thấy mình kém cỏi hơn mà tự ti.</p>

<h3 id="2-vậy-làm-sao-để-hết-để-tâm-đến-người-khác">2. Vậy làm sao để hết để tâm đến người khác\?</h3>

<p>Câu trả lời của câu hỏi này cũng chính là chìa khóa cho việc tự ti. Hãy ngừng so sánh. Ngừng quan tâm ai khác nghĩ gì. Hãy nghĩ về chính mình. Hôm nay áo mình bị bẩn, nếu mình không cố gắng che giấu, mà thoải mái như bình thường, có thể sẽ có người để ý vết bẩn đó, nhưng họ sẽ bị sự tự tin của mình làm xao nhãng. Hay khi bạn thử một phong cách mới, nếu bạn tỏ vẻ xấu hổ, mọi người sẽ nghĩ bạn có khiếu thẩm mỹ dở tệ, và họ sẽ chẳng bao giờ ăn mặc như bạn. Nhưng ngược lại, nếu bạn tự tin sải bước trong bộ đồ mới, tự tin nói cười, mọi người sẽ mong được như bạn, rồi học theo cách ăn mặc của bạn. Thái độ làm nên tất cả.</p>

<p>Trong một tình huống khác, nếu bạn tự ti vì năng lực của bản thân, hãy nghĩ rằng có nhiều việc họ chẳng thể làm tốt như bạn. Đơn giản hơn, bạn hãy nghĩ đó là do họ được tiếp xúc trước, được làm trước nên họ giỏi hơn thôi. Nếu bạn được làm, được học như vậy thì có khi bạn còn xuất sắc hơn họ.</p>

<h3 id="3-nghệ-thuật-lờ-đi-một-ai-khác">3. Nghệ thuật lờ đi một ai khác</h3>

<p>Lờ đi lời nói của ai đó là nghệ thuật, vì chúng ta cần chọn lọc người để lờ đi. Đối với những ý kiến không mang tính xây dựng, chỉ nhằm chọc phá hay khiến bạn tự ti, hãy mạnh dạn lờ chúng đi. Khi bạn làm được điều gì đó, hãy lờ đi những câu như &ldquo;ờ đẹp đấy, nhưng còn đơn giản quá nhỉ&rdquo; hay &ldquo;học hành bao lâu mà làm được thế này thôi à&rdquo;. Hãy tiếp thu các câu như &ldquo;cách này hay đấy, tui/anh/chị/em có cách này cũng hay nè, mình thử kết hợp lại xem sao&rdquo;&hellip; Hãy sáng suốt phân biệt các lời khuyên có tính xây dựng và không có tính xây dựng, có thể dựa vào nội dung câu nói hoặc thái độ của người nói. Nên nhớ, bạn sống cuộc sống của bạn, không sống giùm họ, không xài tiền của họ, cũng không ăn cơm của họ, bởi vậy bạn không cần phải sống theo ý họ (trừ khi họ là sếp của bạn)</p>

<h3 id="4-tin-vào-chính-mình">4. Tin vào chính mình</h3>

<p>Well, câu chuyện muôn thuở, nếu bạn muốn người khác tin bạn thì bạn phải tin vào chính mình trước đã. Tin rằng bạn sẽ học được cái này. Tin rằng bạn sẽ làm được khi bạn cố gắng. Tin rằng bạn sẽ đạt được kết quả như mong đợi. Tin một cách thực tế dựa trên năng lực của chính mình. Như vậy bạn sẽ đạt đến trình độ tự học - tự lập - tự tin. Hãy sống, chiến đấu và không ngừng tiến lên. Chúc bạn may mắn!</p>

<h3 id="5-nói-thì-dễ-làm-thì-khó">5. Nói thì dễ, làm thì khó</h3>

<p>Mình là điển hình cho việc tự làm khó mình. Mình rất thường xuyên để ý đến người khác, xem họ làm gì, xem họ có bàn tán gì về mình không,&hellip; Nói thì dễ, làm thì khó. Tất nhiên mình mong mình làm được những điều mình vừa nói, nhưng cũng thật khó để làm tất cả. Mình hay tự nhấn chìm mình trong những suy nghĩ tối tăm, hay so sánh với người khác, hay vùi dập bản thân ngay từ những bước đầu. Mình biết điều đó rất có hại, và mình cũng đang cố gắng từ bỏ nó để khiến mình thanh thản hơn.</p>

<p>Những điều mình viết ra đây cũng để nhắc nhở mình, bớt suy nghĩ phức tạp lại, tập trung vào mục tiêu đã đề ra nhiều hơn.</p>

<p>Cảm ơn các bạn đã đọc!</p>
]]></content>
		</item>
		
		<item>
			<title>Đi tìm lẽ sống</title>
			<link>https://vzunnbii.github.io/posts/dtls/</link>
			<pubDate>Fri, 12 Apr 2019 09:40:34 +0700</pubDate>
			
			<guid>https://vzunnbii.github.io/posts/dtls/</guid>
			<description>Verbal thinking Đôi dòng cảm nhận qua cuốn sách &amp;ldquo;Đi tìm lẽ sống&amp;rdquo;  Sống trên đời, có ai chưa từng trải qua khổ đau. Có lẽ, sống mà chưa từng đau khổ, sẽ chẳng thể biết được bản thân may mắn đến thế nào&amp;hellip;
 Lẽ sống Bạn có bao giờ tự hỏi bạn sinh ra trên cuộc đời này để làm gì không? Câu hỏi tưởng chừng rất đơn giản, nhưng lại khiến người ta suy ngẫm.</description>
			<content type="html"><![CDATA[

<h1 id="verbal-thinking">Verbal thinking</h1>

<h2 id="đôi-dòng-cảm-nhận-qua-cuốn-sách-đi-tìm-lẽ-sống">Đôi dòng cảm nhận qua cuốn sách &ldquo;Đi tìm lẽ sống&rdquo;</h2>

<blockquote>
<p><em>Sống trên đời, có ai chưa từng trải qua khổ đau. Có lẽ, sống mà chưa từng đau khổ, sẽ chẳng thể biết được bản thân may mắn đến thế nào&hellip;</em></p>
</blockquote>

<p><img src="https://dablogg.com/wp-content/uploads/2018/08/di-tim-le-song.jpg" alt="alt" /></p>

<h3 id="lẽ-sống">Lẽ sống</h3>

<p>Bạn có bao giờ tự hỏi bạn sinh ra trên cuộc đời này để làm gì không? Câu hỏi tưởng chừng rất đơn giản, nhưng lại khiến người ta suy ngẫm. Con sâu ăn lá, con cá phải bơi. Nhưng con người thì khác, không ai có mục đích sống giống nhau, và cũng không ai có chung tư tưởng. Chính điều chúng ta hướng tới đó, chính những trăn trở về mục đích của bản thân đó, khiến chúng ta sống chứ không đơn thuần là tồn tại. Đối với những người còn đang loay hoay đi tìm đường đi cho chính mình, hoặc đang lạc lối giữa cuộc đời, cuốn sách Đi tìm lẽ sống có lẽ sẽ giúp được đôi điều.</p>

<h3 id="đi-tìm-lẽ-sống">Đi tìm lẽ sống</h3>

<p>Cuốn sách Đi tìm lẽ sống của nhà văn Viktor E.Frankl kể về quá trình nhà văn vượt qua cuộc sống khổ sở tại bốn trại tập trung của Đức Quốc xã dưới thời thế chiến thứ hai. Cuốn sách gồm hai phần, những trải nghiệm chân thực tại trại tập trung và sơ lược về liệu pháp ý nghĩa. Cuốn tự truyện hoàn toàn không tập trung vào sự hy sinh của những con người mạnh mẽ, mà cận cảnh vào sự đau khổ, sự giày vò và cái chết của những con người vô danh, những người không có dấu hiệu đặc biệt trên tay áo, những người bình thường đến không có một tài liệu nào ghi nhận. Chính họ mới là những người chịu ảnh hưởng nhiều nhất trong cuộc chiến ấy.</p>

<h3 id="ý-nghĩa-cuộc-sống">Ý nghĩa cuộc sống</h3>

<p>Viktor E.Frankl là một bác sỹ tâm lý, ông có tầm hiểu biết và vốn kiến thức sâu rộng. Ông đã khẳng định rằng, mỗi người có ý nghĩa cuộc sống khác nhau, và nó thay đổi theo từng ngày, từng giờ. <em>Mỗi người đều đảm nhận một công việc, một vai trò cụ thể trong cuộc sống.</em> Và ý nghĩa cuộc sống đều phải do chính bản thân mình tự nỗ lực tìm tòi và khám phá, từ đó biết tự có trách nhiệm với bản thân (Theo liệu pháp ý nghĩa).</p>

<h3 id="ý-nghĩa-của-yêu-thương">Ý nghĩa của yêu thương</h3>

<p><em>Tình yêu là cách duy nhất để thấu hiểu đến tận cùng của một con người.</em> Thông qua tình yêu, một người có thể tìm thấy lẽ sống, tìm thấy người để mình sẵn sàng hy sinh để bảo vệ, chở che. Tình yêu không đơn thuần là tình dục, tình yêu có thể giúp con người nhận ra những tiềm năng của bản thân, biết sống và quý trọng những điều nhỏ bé. Từ sự đồng điệu trong tâm hồn và cảm thông chia sẻ, tình yêu có những sức mạnh vô hình nhưng to lớn giúp định hướng cho mỗi con người.&rsquo;</p>

<h3 id="ý-nghĩa-của-đau-khổ">Ý nghĩa của đau khổ</h3>

<p>Không ai muốn đắm chìm trong đau khổ. Nhắc đến đau khổ là nhắc đến những điều không ai muốn nhớ. Thế nhưng lại có những điều chỉ có đau khổ mới làm được, chính là giúp chúng ta nhận ra chính mình trong hoàn cảnh. Đau khổ không chỉ là điều để quên, nó là đòn bẩy, là thử thách để chúng ta thay đổi chính mình. Nếu không thể thay đổi hoàn cảnh, chúng ta có thể thay đổi thái độ của mình, cách bản thân nhìn nhận khó khăn. Sẽ thật tuyệt vọng khi biết người mình yêu thương rời xa, nhưng đó lại là sự giải thoát nếu người ấy đã phải chịu nhiều giày vò từ căn bệnh. Tất nhiên không cần thiết phải đâm đầu vào tự làm khổ mình, nhưng khi bất hạnh đó không thể tránh khỏi, hãy đương đầu. Vì một ý chí mạnh mẽ, một sức khỏe thần kinh chính là thứ giúp con người vượt qua giông bão.</p>

<h3 id="3-nguồn-ý-nghĩa-của-đời-người">3 nguồn ý nghĩa của đời người</h3>

<h4 id="1-thành-tựu-trong-công-việc">1. Thành tựu trong công việc</h4>

<p>Ai cũng cần có một công việc để mưu sinh, cho dù là giàu nghèo, già trẻ, lớn bé, sang hèn. Khi thực sự nỗ lực và dành tâm huyết cho công việc, bạn sẽ thực sự đạt được một điều gì đó trong sự nghiệp của mình. Thành tựu trong định nghĩa của mỗi người thì đều khác nhau, hãy luôn đặt mục tiêu cho mình và nỗ lực đạt được mục tiêu đó, thành công sẽ theo đuổi bạn.</p>

<h4 id="2-sự-quan-tâm-chăm-sóc-dành-cho-người-thân-yêu">2. Sự quan tâm chăm sóc dành cho người thân yêu</h4>

<p>Tình yêu là cách duy nhất để thấu hiểu đến tận cùng một con người.
Không ai có thể nhận thức đầy đủ về bản chất của một con người trừ khi đã đem lòng yêu thương người ấy. Bằng tình yêu, một người có thể nhìn thấy những phẩm chất và đặc tính cần thiết ở người mình yêu thương; và hơn nữa, người ấy còn nhìn thấy được những năng lực tiềm ẩn của bản thân – những năng lực tuy chưa phát triển hết nhưng cần phải được phát triển. Hơn nữa, bằng tình yêu của mình, người đó có thể khiến cho người mình yêu thương nhận ra những tiềm năng ở họ. Bằng cách nhận ra mình có thể là người thế nào và mình sẽ trở thành người ra sao, người đó sẽ biến những tiềm năng ấy thành sự thật.</p>

<p>Không chỉ với người yêu, những người thân trong gia đình cũng là một phần không thể thiếu. Họ là những người thực sự yêu thương chúng ta mà không kể hoàn cảnh, không màng danh lợi địa vị. Chính họ là người giúp chúng ta được là chính mình.</p>

<h4 id="3-sự-dũng-cảm-đối-mặt-với-khó-khăn-thử-thách">3. Sự dũng cảm đối mặt với khó khăn thử thách</h4>

<p>Cuộc sống luôn đầy rẫy những trắc trở, khó khăn. Để vượt qua được những khó khăn ấy, hãy can đảm, giữ vững tinh thần và giữ bình tĩnh. Nếu không thể thay đổi hoàn cảnh, hãy thay đổi thái độ, thay đổi góc nhìn, bạn sẽ tìm thấy ý nghĩa của sự chịu đựng.</p>

<h3 id="cuộc-sống-ý-nghĩa">Cuộc sống ý nghĩa</h3>

<p>Mỗi người đều có suy nghĩ riêng, định nghĩa riêng về một cuộc sống ý nghĩa. Không nhất thiết phải làm điều gì lớn lao, thay đổi vận mệnh nhân loại mới là ý nghĩa. Tự làm chủ cuộc sống của mình cũng là một cuộc sống ý nghĩa.</p>

<p>Cuộc sống ngắn ngủi, vì thế chúng ta đừng mải mê theo đuổi một định nghĩa mơ hồ nào đó. Hãy tìm kiếm điểm riêng của mình, tìm cho mình một mục tiêu để phấn đấu, tìm cho mình ánh sáng nơi cuối đường hầm. Để bắt đầu cuộc tìm kiếm đó, đừng tìm ở nơi nào xa xôi, hãy bắt đầu ở chính nơi mình đang đứng. Đừng chỉ làm cho qua, làm cho xong, hãy thực sự để tâm vào điều gì đó, hãy thực sự bắt đầu học hỏi. Hãy đặt mục tiêu cao hơn những gì trước đây mình từng đạt được. Hãy chia sẻ nhiều hơn, quan tâm nhiều hơn đến người mình yêu thương. Khi đã có cho mình một chút gốc rễ của niềm tin, hãy giữ vững nó, phát triển nó, và dùng nó để phát triển chính mình. Khi đó dù có khó khăn hay bi kịch, chỉ cần bạn giữ vững niềm tin về tương lai, nhìn nhận vào những mặt tích cực dù là nhỏ bé, bạn sẽ vượt qua được tất cả và tìm cho mình lối đi riêng giữa muôn vàn ngã rẽ cuộc đời.</p>

<h3 id="tạm-kết">Tạm kết</h3>

<p>Cuộc sống không phải lúc nào cũng bằng phẳng. Sông có khúc, người có lúc. Điều tôi muốn nói ở đây không phải là hướng dẫn các bạn vượt qua khó khăn của cuộc sống, mà là mong các bạn luôn giữ được một niềm tin, một ý nghĩa sống nào đó cho bản thân mình. Điều đó có thể thay đổi theo thời gian, như học sinh thì mong đậu đại học, sinh viên thì mong ra trường,&hellip; hoặc là những điều lớn lao như thay đổi thế giới, chứng minh tiếng nói riêng. Có ý nghĩa sống tức là đã sống, chứ không phải là tồn tại, là biết đi có mục đích, biết hy sinh và biết chấp nhận. Sẽ chẳng có sổ tay hướng dẫn nào để giúp một người tìm được lẽ sống của riêng mình. Hãy giữ vững niềm tin. Hãy luôn tìm cho mình một góc nhìn tươi sáng, hãy luôn giữ một thái độ lạc quan. Thông qua từng trải nghiệm, từng bước đi, những gì đọng lại trong chúng ta chính là liều thuốc cho tinh thần khỏe mạnh, để tiếp tục đương đầu với khó khăn.</p>
]]></content>
		</item>
		
	</channel>
</rss>
